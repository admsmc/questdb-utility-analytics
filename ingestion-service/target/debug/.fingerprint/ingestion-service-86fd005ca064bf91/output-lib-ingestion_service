{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `tokio`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":177,"byte_end":182,"line_start":6,"line_end":6,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use tokio::sync::mpsc;","highlight_start":5,"highlight_end":10}],"label":"use of unresolved module or unlinked crate `tokio`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":177,"byte_end":182,"line_start":6,"line_end":6,"column_start":5,"column_end":10,"is_primary":true,"text":[{"text":"use tokio::sync::mpsc;","highlight_start":5,"highlight_end":10}],"label":null,"suggested_replacement":"Tokio","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `tokio`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use tokio::sync::mpsc;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `tokio`\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a crate or module with a similar name\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[91m- \u001b[0muse \u001b[91mtokio\u001b[0m::sync::mpsc;\n\u001b[1m\u001b[94m6\u001b[0m \u001b[92m+ \u001b[0muse \u001b[92mTokio\u001b[0m::sync::mpsc;\n  \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `Server` in `axum`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":1775,"byte_end":1781,"line_start":62,"line_end":62,"column_start":35,"column_end":41,"is_primary":true,"text":[{"text":"            if let Err(e) = axum::Server::bind(&addr)","highlight_start":35,"highlight_end":41}],"label":"could not find `Server` in `axum`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: could not find `Server` in `axum`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:62:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if let Err(e) = axum::Server::bind(&addr)\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mcould not find `Server` in `axum`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `tokio`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":447,"byte_end":452,"line_start":18,"line_end":18,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    receiver: Arc<tokio::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,","highlight_start":19,"highlight_end":24}],"label":"use of unresolved module or unlinked crate `tokio`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":447,"byte_end":452,"line_start":18,"line_end":18,"column_start":19,"column_end":24,"is_primary":true,"text":[{"text":"    receiver: Arc<tokio::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,","highlight_start":19,"highlight_end":24}],"label":null,"suggested_replacement":"Tokio","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing one of these modules","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::sync;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use Tokio::sync;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `sync`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":447,"byte_end":454,"line_start":18,"line_end":18,"column_start":19,"column_end":26,"is_primary":true,"text":[{"text":"    receiver: Arc<tokio::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,","highlight_start":19,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `tokio`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:18:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     receiver: Arc<tokio::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `tokio`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a crate or module with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[91m- \u001b[0m    receiver: Arc<\u001b[91mtokio\u001b[0m::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,\n\u001b[1m\u001b[94m18\u001b[0m \u001b[92m+ \u001b[0m    receiver: Arc<\u001b[92mTokio\u001b[0m::sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these modules\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use std::sync;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use Tokio::sync;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `sync`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m18\u001b[0m \u001b[91m- \u001b[0m    receiver: Arc<\u001b[91mtokio::\u001b[0msync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,\n\u001b[1m\u001b[94m18\u001b[0m \u001b[92m+ \u001b[0m    receiver: Arc<sync::Mutex<Option<mpsc::Receiver<Envelope<MeterUsage>>>>>,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `time`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":583,"byte_end":587,"line_start":23,"line_end":23,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    ts: time::OffsetDateTime,","highlight_start":9,"highlight_end":13}],"label":"use of unresolved module or unlinked crate `time`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you wanted to use a crate named `time`, use `cargo add time` to add it to your `Cargo.toml`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"consider importing this module","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use sqlx::types::time;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `time`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:23:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     ts: time::OffsetDateTime,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `time`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: if you wanted to use a crate named `time`, use `cargo add time` to add it to your `Cargo.toml`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this module\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use sqlx::types::time;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `tokio`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":2034,"byte_end":2039,"line_start":71,"line_end":71,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"            receiver: Arc::new(tokio::sync::Mutex::new(Some(rx))),","highlight_start":32,"highlight_end":37}],"label":"use of unresolved module or unlinked crate `tokio`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":2034,"byte_end":2039,"line_start":71,"line_end":71,"column_start":32,"column_end":37,"is_primary":true,"text":[{"text":"            receiver: Arc::new(tokio::sync::Mutex::new(Some(rx))),","highlight_start":32,"highlight_end":37}],"label":null,"suggested_replacement":"Tokio","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"consider importing one of these structs","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::sync::Mutex;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::sync::nonpoison::Mutex;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use Tokio::sync::Mutex;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use futures::lock::Mutex;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `Mutex`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":2034,"byte_end":2047,"line_start":71,"line_end":71,"column_start":32,"column_end":45,"is_primary":true,"text":[{"text":"            receiver: Arc::new(tokio::sync::Mutex::new(Some(rx))),","highlight_start":32,"highlight_end":45}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `tokio`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:71:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             receiver: Arc::new(tokio::sync::Mutex::new(Some(rx))),\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `tokio`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a crate or module with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[91m- \u001b[0m            receiver: Arc::new(\u001b[91mtokio\u001b[0m::sync::Mutex::new(Some(rx))),\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ \u001b[0m            receiver: Arc::new(\u001b[92mTokio\u001b[0m::sync::Mutex::new(Some(rx))),\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing one of these structs\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use std::sync::Mutex;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use std::sync::nonpoison::Mutex;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use Tokio::sync::Mutex;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use futures::lock::Mutex;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `Mutex`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[91m- \u001b[0m            receiver: Arc::new(\u001b[91mtokio::sync::\u001b[0mMutex::new(Some(rx))),\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ \u001b[0m            receiver: Arc::new(Mutex::new(Some(rx))),\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `clone` exists for struct `Box<dyn Transform<T, T> + std::marker::Send + Sync>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/pipeline/mod.rs","byte_start":1630,"byte_end":1635,"line_start":59,"line_end":59,"column_start":27,"column_end":32,"is_primary":true,"text":[{"text":"                let t = t.clone();","highlight_start":27,"highlight_end":32}],"label":"method cannot be called due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/pipeline/mod.rs","byte_start":618,"byte_end":656,"line_start":29,"line_end":29,"column_start":1,"column_end":39,"is_primary":false,"text":[{"text":"pub trait Transform<I, O>: Send + Sync {","highlight_start":1,"highlight_end":39}],"label":"doesn't satisfy `_: Clone` or `_: Sized`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`dyn Transform<T, T> + std::marker::Send + Sync: Sized`\nwhich is required by `Box<dyn Transform<T, T> + std::marker::Send + Sync>: Clone`\n`dyn Transform<T, T> + std::marker::Send + Sync: Clone`\nwhich is required by `Box<dyn Transform<T, T> + std::marker::Send + Sync>: Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `clone`, perhaps you need to implement it:\ncandidate #1: `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `clone` exists for struct `Box<dyn Transform<T, T> + std::marker::Send + Sync>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/pipeline/mod.rs:59:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Transform<I, O>: Send + Sync {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `_: Clone` or `_: Sized`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m59\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let t = t.clone();\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called due to unsatisfied trait bounds\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `dyn Transform<T, T> + std::marker::Send + Sync: Sized`\n           which is required by `Box<dyn Transform<T, T> + std::marker::Send + Sync>: Clone`\n           `dyn Transform<T, T> + std::marker::Send + Sync: Clone`\n           which is required by `Box<dyn Transform<T, T> + std::marker::Send + Sync>: Clone`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait defines an item `clone`, perhaps you need to implement it:\n           candidate #1: `Clone`\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: use of unresolved module or unlinked crate `tokio`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":1715,"byte_end":1720,"line_start":61,"line_end":61,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"        tokio::spawn(async move {","highlight_start":9,"highlight_end":14}],"label":"use of unresolved module or unlinked crate `tokio`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a crate or module with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":1715,"byte_end":1720,"line_start":61,"line_end":61,"column_start":9,"column_end":14,"is_primary":true,"text":[{"text":"        tokio::spawn(async move {","highlight_start":9,"highlight_end":14}],"label":null,"suggested_replacement":"Tokio","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0433]\u001b[0m\u001b[1m: failed to resolve: use of unresolved module or unlinked crate `tokio`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:61:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         tokio::spawn(async move {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91muse of unresolved module or unlinked crate `tokio`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a crate or module with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[91m- \u001b[0m        \u001b[91mtokio\u001b[0m::spawn(async move {\n\u001b[1m\u001b[94m61\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92mTokio\u001b[0m::spawn(async move {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/sources/http_json.rs","byte_start":2384,"byte_end":2389,"line_start":84,"line_end":84,"column_start":18,"column_end":23,"is_primary":false,"text":[{"text":"        let rx = guard","highlight_start":18,"highlight_end":23}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":2327,"byte_end":2336,"line_start":83,"line_end":83,"column_start":13,"column_end":22,"is_primary":true,"text":[{"text":"        let mut guard = self.receiver.lock().await;","highlight_start":13,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving `guard` an explicit type","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":2336,"byte_end":2336,"line_start":83,"line_end":83,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        let mut guard = self.receiver.lock().await;","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:83:13\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut guard = self.receiver.lock().await;\n   \u001b[1m\u001b[94m|\u001b[0m             \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m84\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let rx = guard\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving `guard` an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m83\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        let mut guard\u001b[92m: /* Type */\u001b[0m = self.receiver.lock().await;\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `map` exists for struct `ReceiverStream<_>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/Users/andrewmathers/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-stream-0.1.18/src/wrappers/mpsc_bounded.rs","byte_start":941,"byte_end":969,"line_start":34,"line_end":34,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"pub struct ReceiverStream<T> {","highlight_start":1,"highlight_end":29}],"label":"doesn't satisfy `ReceiverStream<_>: Iterator`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":2545,"byte_end":2548,"line_start":88,"line_end":88,"column_start":46,"column_end":49,"is_primary":true,"text":[{"text":"        let stream = ReceiverStream::new(rx).map(Ok);","highlight_start":46,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`ReceiverStream<_>: Iterator`\nwhich is required by `&mut ReceiverStream<_>: Iterator`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits which provide `map` are implemented but not in scope; perhaps you want to import one of them","code":null,"level":"help","spans":[{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use futures::StreamExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/sources/http_json.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::{net::SocketAddr, sync::Arc, time::SystemTime};","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio_stream::StreamExt;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `map` exists for struct `ReceiverStream<_>`, but its trait bounds were not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sources/http_json.rs:88:46\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m88\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let stream = ReceiverStream::new(rx).map(Ok);\n   \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[91m^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0m/Users/andrewmathers/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-stream-0.1.18/src/wrappers/mpsc_bounded.rs:34:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ReceiverStream<T> {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `ReceiverStream<_>: Iterator`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n           `ReceiverStream<_>: Iterator`\n           which is required by `&mut ReceiverStream<_>: Iterator`\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: the following traits which provide `map` are implemented but not in scope; perhaps you want to import one of them\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use futures::StreamExt;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m1\u001b[0m \u001b[92m+ use tokio_stream::StreamExt;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 9 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0282, E0433, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0282, E0433, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0282`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0282`.\u001b[0m\n"}
